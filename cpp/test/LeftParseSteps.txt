I have done this exercise by hand. My parser cuts short many rules, thus changing the parser code to
print out the results is more tiresome than doing it manually.
If you just want the left parse without all the details, please skip to the end of this file.
All the rule numbers are taken from your Parser Design slides.

Step)	ParentStep.	RuleNo: 	Rule::=		Expansion				[StepDone]	

1)	/ 		1:		Program::= 	Program SumTwoInt; <Block> .		[51]
2)	1.		3:		Block::= 	<Block2>				[51]
3)	2.		5:		Block2::=	<Block3>				[51]
4)	3.		6:		Block3::=	Var <VarDecl> <VarDecls> <Block4>	[51]
5)	4.		18:		VarDecl::=	First: Integer;				[5]		
6)	4.		16:		VarDecls::=	<VarDecl> <VarDecls>			[8]	
7)	6.		18:		VarDecl::=	Second: Integer;			[7]	
8)	6.		17:		VarDecls::= 	/nothing				[8]
9)	4.		8:		Block4::=	<Block5>				[51]
10)	9.		9:		Block5::=	Begin <Statements> End			[51]
11)	10.		46:		Statements:=	<Statement> <Statements2>		[51]

12)	11.		50:		Statement:=	<CallSt>				[22]
13)	12.		57:		CallSt::=	Call ReadI <Arguments>			[22]
14)	13.		64:		Arguments::=	( <Expression> <Arguments2> )		[22]
15)	14.		77:		Expression::=	<Expression2>				[21]
16)	15.		78:		Expression2::=	<Term> <Expression3>			[21]
17)	16.		82:		Term::=		<Factor> <Term2>			[20]
18)	17.		88:		Factor::=	First <Indexes>				[19]
19)	18.		94:		Indexes::=	/nothing				[19]
20)	17.		85:		Term2::=	/nothing				[20]
21)	19.		81:		Expression3::=	/nothing				[21]
22)	14.		57:		Arguments2::=	/nothing				[22]

23)	11.		47:		Statements2::=	; <Statement> <Statements2>		[51]

24)	23.		50:		Statement:=	<CallSt>				[34]
25)	24.		57:		CallSt::=	Call ReadI <Arguments>			[34]
26)	25.		64:		Arguments::=	( <Expression> <Arguments2> )		[34]
27)	26.		77:		Expression::=	<Expression2>				[33]
28)	27.		78:		Expression2::=	<Term> <Expression3>			[33]
29)	28.		82:		Term::=		<Factor> <Term2>			[32]
30)	29.		88:		Factor::=	First <Indexes>				[31]
31)	30.		94:		Indexes::=	/nothing				[31]
32)	29.		85:		Term2::=	/nothing				[32]
33)	31.		81:		Expression3::=	/nothing				[33]
34)	26.		57:		Arguments2::=	/nothing				[34]

35)	23.		47:		Statements2::=	; <Statement> <Statements2>		[51]

36)	35.		50:		Statement:=	<CallSt>				[51]
37)	36.		57:		CallSt::=	Call WriteI <Arguments>			[51]
38)	37.		64:		Arguments::=	( <Expression> <Arguments2> )		[51]
39)	38.		77:		Expression::=	<Expression2>				[50]
40)	39.		78:		Expression2::=	<Term> <Expression3>			[50]
41)	40.		82:		Term::=		<Factor> <Term2>			[44]
42)	41.		88:		Factor::=	First <Indexes>				[43]
43)	42.		94:		Indexes::=	/nothing				[43]
44)	41.		85:		Term2::=	/nothing				[44]
45)	40.		79:		Expression3::=	+ <Term> <Expression3>			[50]
46)	45.		82:		Term::=		<Factor> <Term2>			[49]
47)	46.		88:		Factor::=	Second <Indexes>			[48]
48)	47.		94:		Indexes::=	/nothing				[48]
49)	46.		85:		Term2::=	/nothing				[49]
50)	45.		82:		Expression3::=	/nothing				[50]
51)	38.		67:		Arguments2::=	/nothing				[51]


The anti-derivation rule at each step:
(Step: Rules)
5: 18
7: 18
8: 17 16

19: 94 88
20: 85 82
21: 81 78 77
22: 57 64 57 50

31: 94 88
32: 85 82
33: 81 78 77
34: 57 64 57 50

43: 94 88
44: 85 82
48: 94 88
49: 85 82
50: 82 79 78 77
51: 67 64 57 50 47 47 46 9 8 6 5 3 1

Finally, the left parse of program SumTwoInt:
18 18 17 16 94 88 85 82 81 78 77 57 64 57 50 94 88 85 82 81 78 77 57 64 57 50 94 88 85 82 94 88 85 82 82 79 78 77 67 64 57 50 47 47 46 9 8 6 5 3 1
